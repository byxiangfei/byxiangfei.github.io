---
layout: post
title: LC Google High Frequency
categories: Leetcode
description: google
keywords: Leetcode
---


##Tag: String

#### [LC68. Text Justification](https://leetcode.com/problems/text-justification/description/)
[解题方案](http://www.cnblogs.com/grandyang/p/4350381.html)


#### [LC388. Longest Absolute File Path](https://leetcode.com/problems/longest-absolute-file-path/description/)
[解题方案](http://www.cnblogs.com/grandyang/p/5806493.html)


#### LC394. Decode String
```
s = "3[a]2[bc]", return "aaabcbc".
s = "3[a2[c]]", return "accaccacc".
s = "2[abc]3[cd]ef", return "abcabccdcdcdef".
```
[解题方案](http://www.cnblogs.com/grandyang/p/5849037.html)


### LC734.Sentence Similarity (LOCK)
```
Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.

For example, "great acting skills" and "fine drama talent" are similar, if the similar word pairs are pairs = [["great", "fine"], ["acting","drama"], ["skills","talent"]].

Note that the similarity relation is not transitive. For example, if "great" and "fine" are similar, and "fine" and "good" are similar, "great" and "good" are not necessarily similar.

However, similarity is symmetric. For example, "great" and "fine" being similar is the same as "fine" and "great" being similar.

Also, a word is always similar with itself. For example, the sentences words1 = ["great"], words2 = ["great"], pairs = [] are similar, even though there are no specified similar word pairs.

Finally, sentences can only be similar if they have the same number of words. So a sentence like words1 = ["great"] can never be similar to words2 = ["doubleplus","good"].

Note:
The length of words1 and words2 will not exceed 1000.
The length of pairs will not exceed 2000.
The length of each pairs[i] will be 2.
The length of each words[i] and pairs[i][j] will be in the range [1, 20].
```
[解题思路](http://www.cnblogs.com/grandyang/p/8053934.html)

#####Solution 1

~~~
class Solution {
public:
    bool areSentencesSimilar(vector<string>& words1, vector<string>& words2, vector<pair<string, string>> pairs) {
        if (words1.size() != words2.size()) return false;
        map<string, set<string>> map;
        for (pair<string, string> p : pairs)
            map[p.first].insert(p.second);

        for (int i = 0; i < words1.size(); i++)
            if (words1[i] != words2[i] && !map[words1[i]].count(words2[i]) && !map[words2[i]].count(words1[i]))
                return false;
        return true;
    }
};
written by alexander original link here
~~~

#####Solution 2
~~~
Time complexity: O(nk), space complexity O(nk). n is number of words, k is the average length of words.

class Solution {
    public boolean areSentencesSimilar(String[] words1, String[] words2, String[][] pairs) {
        if (words1.length != words2.length) return false;
        Map<String, Set<String>> map = new HashMap<>();
        
        for (String[] p : pairs) {
            Set<String> set0 = map.getOrDefault(p[0], new HashSet<>());
            set0.add(p[1]);
            map.put(p[0], set0);
            
            Set<String> set1 = map.getOrDefault(p[1], new HashSet<>());
            set1.add(p[0]);
            map.put(p[1], set1);
        }
        
        for (int i = 0; i < words1.length; i++) {
            if (words1[i].equals(words2[i])) continue;
            if (map.containsKey(words1[i]) && map.get(words1[i]).contains(words2[i])) continue;
            return false;
        }
        
        return true;
    }
}
~~~


###LC737. Sentence Similarity II (Lock)

~~~
Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.

For example, words1 = ["great", "acting", "skills"] and words2 = ["fine", "drama", "talent"] are similar, if the similar word pairs are pairs = [["great", "good"], ["fine", "good"], ["acting","drama"], ["skills","talent"]].

Note that the similarity relation is transitive. For example, if "great" and "good" are similar, and "fine" and "good" are similar, then "great" and "fine" are similar.

Similarity is also symmetric. For example, "great" and "fine" being similar is the same as "fine" and "great" being similar.

Also, a word is always similar with itself. For example, the sentences words1 = ["great"], words2 = ["great"], pairs = [] are similar, even though there are no specified similar word pairs.

Finally, sentences can only be similar if they have the same number of words. So a sentence like words1 = ["great"] can never be similar to words2 = ["doubleplus","good"].

Note:

The length of words1 and words2 will not exceed 1000.
The length of pairs will not exceed 2000.
The length of each pairs[i] will be 2.
The length of each words[i] and pairs[i][j] will be in the range [1, 20].
~~~

#####Solution 1
Build the graph according to the similar word pairs. Each word is a graph node.
For each word in words1, we do DFS search to see if the corresponding word is existing in words2.
See the clean code below. Happy coding!

~~~
class Solution {
    public boolean areSentencesSimilarTwo(String[] words1, String[] words2, String[][] pairs) {
        if (words1.length != words2.length) {
            return false;
        }
        
        //Build the graph;
        Map<String, Set<String>> pairInfo = new HashMap<>();      
        for (String[] pair : pairs) {
            if (!pairInfo.containsKey(pair[0])) {
                pairInfo.put(pair[0], new HashSet<>());
            }
            if (!pairInfo.containsKey(pair[1])) {
                pairInfo.put(pair[1], new HashSet<>());
            }         
            pairInfo.get(pair[0]).add(pair[1]);
            pairInfo.get(pair[1]).add(pair[0]);
        }
        
        for (int i = 0; i < words1.length; i++) {
            if (words1[i].equals(words2[i])) continue;         
            if (!pairInfo.containsKey(words1[i])) return false;      
            if (!dfs(words1[i], words2[i], pairInfo, new HashSet<>())) return false;    //Search the graph.
        }
        
        return true;
    }
    
    public boolean dfs(String source, String target, Map<String, Set<String>> pairInfo, Set<String> visited) {
        if (pairInfo.get(source).contains(target)) return true;
        
        visited.add(source);
        for (String next : pairInfo.get(source)) {
            if (!visited.contains(next) && dfs(next, target, pairInfo, visited)) {
                return true;
            }
        }
        return false;
    }
}
~~~

###[LC529. Minesweeper](https://leetcode.com/problems/minesweeper/description/)
Return the board when no more squares will be revealed.  
追加问题是如何初始化扫雷地图。 BFS主要是用来扩展'B'用的

~~~
class Solution {
public:
    vector<vector<char>> updateBoard(vector<vector<char>> &board, vector<int> &click) {
        if (board.empty() || board[0].empty()) return {};
        int m = board.size(), n = board[0].size();
        queue<pair<int, int>> q;
        q.emplace(click[0], click[1]);
        while (!q.empty()) {
            int row = q.front().first, col = q.front().second, cnt = 0; q.pop();
            vector<pair<int, int>> neighbors;
            if (board[row][col] == 'M') board[row][col] = 'X';
            else if (board[row][col] == 'E') {
                for (int i = -1; i < 2; i++) {
                    for (int j = -1; j < 2; j++) {
                        int x = row + i, y = col + j;
                        if (x < 0 || y < 0 || x >= m || y >= n) continue;
                        if (board[x][y] == 'M') ++cnt;
                        else neighbors.push_back({x, y});
                    }
                }
                if (cnt > 0) board[row][col] = cnt + '0';
                else {
                    board[row][col] = 'B';
                    for (auto a : neighbors) {
                        q.push(a);
                    }
                }
            }
        }
        return board;
    }
};
~~~

##Tag: Trie

### LC616. Add bold tag in string
给字符串S 和一个关键词集合，要求将每个关键词在 S 中的所有出现都加粗（通过在文本两边添加 <b> 和 </b> 这两个 HTML tag 的方式），输出 S 被加粗后的 HTML 文本。

If two such substrings overlap, you need to wrap them together by only one pair of closed bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine them.

~~~
Example 1:
Input:  s = "abcxyz123", dict = ["abc","123"]
Output: "<b>abc</b>xyz<b>123</b>"
Example 2:
Input:  s = "aaabbcc", dict = ["aaa","aab","bc"]
Output: "<b>aaabbc</b>c" 

Note:
The given dict won't contain duplicates, and its length won't exceed 100.
All the strings in input have length in range [1, 1000].  
~~~

#####Solution 1

Use a boolean array to mark if character at each position is bold or not. After that, things will become simple.

~~~
public class Solution {
    public String addBoldTag(String s, String[] dict) {
        boolean[] bold = new boolean[s.length()];
        for (int i = 0, end = 0; i < s.length(); i++) {
            for (String word : dict) {
                if (s.startsWith(word, i)) {
                    end = Math.max(end, i + word.length());
                }
            }
            bold[i] = end > i;
        }
        
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (!bold[i]) {
                result.append(s.charAt(i));
                continue;
            }
            int j = i;
            while (j < s.length() && bold[j]) j++;
            result.append("<b>" + s.substring(i, j) + "</b>");
            i = j - 1;
        }
        
        return result.toString();
    }
}
~~~


##Tag: BFS

###[LC684.Redundant Connection](https://leetcode.com/problems/redundant-connection/) 
Union Find, BFS, DFS
[解题报表](http://www.cnblogs.com/grandyang/p/7628977.html)